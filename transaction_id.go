package transactionidutils

import (
	"errors"
	"math/rand"
	"net/http"
	"time"

	"golang.org/x/net/context"
)

//TransactionIDHeader is the request header to look for
const TransactionIDHeader = "X-Request-Id"

//TransactionIDKey is the key used to store the value on the context
const TransactionIDKey string = "transaction_id"

var letters = []rune("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ")

func init() {
	rand.Seed(time.Now().UTC().UnixNano())
}

// GetTransactionIDFromRequest will look on the request
// for an 'X-Request-Id' header, and use that value as the returned transactionID.
// If none is found, one will be autogenerated, with a 'tid_' prefix and a random
// ten character string
func GetTransactionIDFromRequest(req *http.Request) string {
	transactionID := req.Header.Get(TransactionIDHeader)
	if transactionID == "" {
		transactionID = NewTransactionID()
		req.Header.Set(TransactionIDHeader, transactionID)
	}
	return transactionID
}

// NewTransactionID generates a new random transaction ID conforming to the FT spec
func NewTransactionID() string {
	return "tid_" + randString(10)
}

// TransactionAwareContext  will take the
// context passed in and store the transactionID on it
func TransactionAwareContext(ctx context.Context, transactionID string) context.Context {
	return context.WithValue(ctx, TransactionIDKey, transactionID)
}

// GetTransactionIDFromContext  will look for a transactionID
// value on the context and return it if found. If none is found, return empty
// string and an error
func GetTransactionIDFromContext(ctx context.Context) (string, error) {
	// ctx.Value returns nil if ctx has no value for the key;
	// string type assertion returns ok=false for nil.
	transactionID, ok := ctx.Value(TransactionIDKey).(string)
	if ok {
		return transactionID, nil
	}
	return "", errors.New("No transactionID found")
}

func randString(n int) string {
	b := make([]rune, n)
	for i := range b {
		b[i] = letters[rand.Intn(len(letters))]
	}
	return string(b)
}
